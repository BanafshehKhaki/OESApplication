// This file has been autogenerated from a class added in the UI designer.

using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using AVFoundation;
using Foundation;
using UIKit;
using AssetsLibrary;
using CoreImage;
using Xamarin.Forms;
using Xamarin.Forms.Platform.iOS;
using CoreFoundation;
using ImageIO;
using CoreMedia;
using CoreGraphics;
using System.Collections;
using System.Threading;
using System.Diagnostics.Contracts;
//using System.Timers;

namespace OESApplication.iOS
{
    public partial class mainViewController : UIViewController
    {


        AVCaptureSession captureSession;
        AVCaptureDeviceInput captureDeviceInput;
        AVCaptureStillImageOutput stillImageOutput;
        AVCaptureVideoPreviewLayer videoPreviewLayer;
        NSData jpegAsByteArray;


        public mainViewController(IntPtr handle) : base(handle)
        {
            //jpegAsByteArray = new int Array();

        }

        public override async void ViewDidLoad()
        {
            base.ViewDidLoad();
            await AuthorizeCameraUse();

            SetupLiveCameraStream();

            //captureSpectraButton.TouchUpInside += (object sender, EventArgs e) => {

                 //takeThepictureAsync().ConfigureAwait(false);

                // Launches a new instance of CallHistoryController

                //resultViewController resultView = this.Storyboard.InstantiateViewController("resultViewController") as resultViewController;
                //if (resultView != null && (jpegAsByteArray != null && jpegAsByteArray.Length > 0))
                //{
                //    resultView.resultoutputtext = "test";
                //    resultView.PixelArray = jpegAsByteArray;
                //    this.NavigationController.PushViewController(resultView, true);
                //}
            //};
        }

        partial void captureSpectraTouchUpInside(Foundation.NSObject sender){
            takeThepictureAsync();
        }

        private async Task MyMethodCallForNotAsync()
        {
            await takeThepictureAsync().ConfigureAwait(false);
        }

        public override bool ShouldPerformSegue(string segueIdentifier, NSObject sender)
        {
            if (segueIdentifier == "SequetoResultsPage")
            {
                if (ArrayisFilledAsync())
                {
                    Console.Write(" jpegAsByteArray is good to go ");
                    return true;
                }
                else
                {
                    Console.Write(" jpegAsByteArray is either null or empty ");
                    return false;
                }
            }
            return base.ShouldPerformSegue(segueIdentifier, sender);
        }

        private bool ArrayisFilledAsync()
        {
            if (jpegAsByteArray != null && jpegAsByteArray.Length > 0){
                Console.WriteLine("good to go ");
                return true;
            }
            else{
                //Thread.Sleep(3000);
                if (jpegAsByteArray != null && jpegAsByteArray.Length <= 100)
                {
                    Console.WriteLine("second check shows array to be sill empty");
                    return false;
                }
            }

            return false; 
        }

		public override void PrepareForSegue(UIStoryboardSegue segue, NSObject sender)
		{
            //
            
            base.PrepareForSegue(segue, sender);

            var resultViewController = segue.DestinationViewController as resultViewController;
            

            if (resultViewController != null)
            {
                //resultViewController.resultoutputtext = "test output";
                resultViewController.PixelArray = jpegAsByteArray;            
				resultViewController.x_crop_loc = (int)CrossHair.Frame.X;
				Console.WriteLine("CrossHair..X: " + CrossHair.Frame.X);
				resultViewController.y_crop_loc = (int)CrossHair.Frame.Y;
				Console.WriteLine("CrossHair..Y: " + CrossHair.Frame.Y);

				resultViewController.widthOfCrossHair = (int)CrossHair.Frame.Width;
				Console.WriteLine("widthOfCrossHair: " + CrossHair.Frame.Width);
				resultViewController.HeightOfCrossHair = (int)CrossHair.Frame.Height;
				Console.WriteLine("HeightOfCrossHair: " + CrossHair.Frame.Height);
				resultViewController.liveCameraWidth = (int)liveCameraStream.Frame.Width;
				resultViewController.liveCameraHeight = (int)liveCameraStream.Frame.Height;

            }
            
        }

      


        public async Task takeThepictureAsync()
        {
            
                var videoConnection = stillImageOutput.ConnectionFromMediaType(AVMediaType.Video);
                var sampleBuffer = await stillImageOutput.CaptureStillImageTaskAsync(videoConnection);

                var jpegImageAsNsData = AVCaptureStillImageOutput.JpegStillToNSData(sampleBuffer);

                jpegAsByteArray = jpegImageAsNsData;

                //Console.WriteLine("rank: " + jpegAsByteArray.Rank + " length: " + jpegAsByteArray.Length);

                var imageMeta = CIImage.FromData(jpegImageAsNsData);
                
                var imagePrev = new UIImage(jpegImageAsNsData);
                ImagePreview.Image =imagePrev ;
			    

                var meta = imageMeta.Properties.Dictionary.MutableCopy() as NSMutableDictionary;


                var library = new ALAssetsLibrary();
                library.WriteImageToSavedPhotosAlbum(jpegImageAsNsData, meta, (assetUrl, error) =>
                {
                    if (error == null)
                    {
                        Console.WriteLine("saved: ");//+jpegImageAsNsData);
                }
                    else
                    {
                        Console.WriteLine(error);
                        UIAlertView alert = new UIAlertView()
                        {
                            Title = "Alert!",
                            Message = "There was a problem with saving your image, please take a new picture"
                        };
                        alert.AddButton("OK");
                        alert.Show();

                    }
                });
          
        }

        async Task AuthorizeCameraUse()
        {
            var authorizationStatus = AVCaptureDevice.GetAuthorizationStatus(AVMediaType.Video);

            if (authorizationStatus != AVAuthorizationStatus.Authorized)
            {
                await AVCaptureDevice.RequestAccessForMediaTypeAsync(AVMediaType.Video);
            }
        }
        public void SetupLiveCameraStream()
        {
            captureSession = new AVCaptureSession();

           

            var viewLayer = liveCameraStream.Layer;
            videoPreviewLayer = new AVCaptureVideoPreviewLayer(captureSession)
            {
                Frame = this.View.Frame,

                //Orientation = AVCaptureVideoOrientation.Portrait
                            
            };

            liveCameraStream.Layer.AddSublayer(videoPreviewLayer);


            //var captureDevice = AVCaptureDevice.DefaultDeviceWithMediaType(AVMediaType.Video);
            var captureDevice = AVCaptureDevice.GetDefaultDevice(AVMediaType.Video);

            ConfigureCameraForDevice(captureDevice);


            captureDeviceInput = AVCaptureDeviceInput.FromDevice(captureDevice);
            captureSession.AddInput(captureDeviceInput);

            var dictionary = new NSMutableDictionary();
            dictionary[AVVideo.CodecKey] = new NSNumber((int)AVVideoCodec.JPEG);
            stillImageOutput = new AVCaptureStillImageOutput()
            {
                OutputSettings = new NSDictionary()
            };

            captureSession.AddOutput(stillImageOutput);
            captureSession.StartRunning();
          
        }



        void ConfigureCameraForDevice(AVCaptureDevice device)
        {
            var error = new NSError();
            if (device.IsFocusModeSupported(AVCaptureFocusMode.ContinuousAutoFocus))
            {
                device.LockForConfiguration(out error);
                //Console.WriteLine();
                device.FocusMode = AVCaptureFocusMode.ContinuousAutoFocus;
                
                //device.AutoFocusRangeRestriction = AVCaptureAutoFocusRangeRestriction.Far;
				device.SetFocusModeLocked((float)0.3, null);
				//device.FocusPointOfInterest = ;
				//device.FocusPointOfInterest =  CoreGraphics.CGPoint((float)0.5, (float) 0.5);
				Console.WriteLine("devidce device.FocusMode: " + device.FocusMode);
                device.UnlockForConfiguration();

            }
            if (device.IsExposureModeSupported(AVCaptureExposureMode.ContinuousAutoExposure))
            {
                device.LockForConfiguration(out error);
                //Console.WriteLine("devidce device.ExposureMode: "+device.ExposureMode);
                            
                //float minexposure =  device.MinExposureTargetBias;
                //float maxexposure = device.MaxExposureTargetBias;
                //float minISO = device.ActiveFormat.MinISO;
                //float maxISO = device.ActiveFormat.MaxISO;
                var minexposureDuration = device.ActiveFormat.MinExposureDuration;
                var maxexposureDuration = device.ActiveFormat.MaxExposureDuration;
               
                
				//device.LockExposure(maxexposureDuration, minISO, null);
				//Console.WriteLine("devidce device.Exposure max duration: " + maxexposureDuration + "devidce device.Exposure min duration: " +
				                  //minexposureDuration + "exposure duration: " + device.ExposureDuration.Value 
				                  //+" iso: "+minISO +"lens aperture: "+ device.LensAperture);
				//device.SetExposureTargetBias(float(maxexposureDuration), null);            

				device.ExposureMode = AVCaptureExposureMode.Custom;



				//In theory if exposure increases by one stop the value of the variable exposure would increase by 1.
				//This is not what I am seeing when I increase exposure bias by 1 though
				//device.ActiveFormat.MaxExposureDuration.Value

				//var shutter = ((float)(device.ExposureDuration.Value) / (float)(device.ExposureDuration.TimeScale));
				var shutter = ((float)(maxexposureDuration.Value) / (float)(device.ExposureDuration.TimeScale));
				var aperture = device.LensAperture;
				var iso = device.ActiveFormat.MaxISO;
				float exposureNaturalLog = (float)Math.Log(aperture * aperture / (shutter * iso / 100));
				var exposure = (int) (exposureNaturalLog /  (float)Math.Log(2));

                
				//device.LockExposure((CMTime.FromSeconds(1, 4)), iso, null);
				device.LockExposure(maxexposureDuration, iso, null);

				//device.SetExposureTargetBias(0,null);



				Console.WriteLine(" 1- zoom: " + device.VideoZoomFactor);
				device.VideoZoomFactor = device.ActiveFormat.VideoMaxZoomFactor;
				Console.WriteLine(" 2- zoom: " + device.VideoZoomFactor);

				Console.WriteLine(" device.ExposureDuration: "+device.ExposureDuration+" ActiveVideoMinFrameDuration: "+device.ActiveVideoMaxFrameDuration +" duration set: " +(CMTime.FromSeconds(1,4).Seconds)+" device exposure values: " + exposure+" MaxExposureTargetBias: "+ device.MaxExposureTargetBias +" aperture: " + aperture +" shutter: " + shutter + " iso: "+iso + " exposureElog: "+exposureNaturalLog);            
				Console.WriteLine("device maxexposureDuration: " + maxexposureDuration + " device.MinExposureTargetBias "+ device.MinExposureTargetBias);

                device.UnlockForConfiguration();
            }

            if (device.IsWhiteBalanceModeSupported(AVCaptureWhiteBalanceMode.AutoWhiteBalance))
            {
                device.LockForConfiguration(out error);
                //Console.WriteLine("devidce device.WhiteBalanceMode: " + device.WhiteBalanceMode);
                device.WhiteBalanceMode = AVCaptureWhiteBalanceMode.ContinuousAutoWhiteBalance;

                //gains = NomralizeGains (gains);
                //ThisApp.CaptureDevice.SetWhiteBalanceModeLockedWithDeviceWhiteBalanceGains (gains, null);
                //gains.RedGain = Math.Max(1, gains.RedGain);
                //gains.BlueGain = Math.Max(1, gains.BlueGain);
                //gains.GreenGain = Math.Max(1, gains.GreenGain);

                //float maxGain = ThisApp.CaptureDevice.MaxWhiteBalanceGain;
                //gains.RedGain = Math.Min(maxGain, gains.RedGain);
                //gains.BlueGain = Math.Min(maxGain, gains.BlueGain);
                //gains.GreenGain = Math.Min(maxGain, gains.GreenGain);


                //// Set min and max values
                //Temperature.MinValue = 1000f;
                //Temperature.MaxValue = 10000f;

                //Tint.MinValue = -150f;
                //Tint.MaxValue = 150f;

                Console.WriteLine("devidce device.WhiteBalanceMode: " + device.WhiteBalanceMode);
                device.UnlockForConfiguration();
            }
        }


        //void RemoveSaturation()
        //{
        //    // use the low-res version
        //    if (colorCtrls == null)
        //        colorCtrls = new CIColorControls() { Image = CIImage.FromCGImage(sourceImage.CGImage) };
        //    else
        //        colorCtrls.Image = CIImage.FromCGImage(sourceImage.CGImage);
        //    // re-use context for efficiency
        //    if (context == null)
        //        context = CIContext.FromOptions(null);
        //    // set the values
        //    colorCtrls.Brightness = sliderBrightness.Value;
        //    colorCtrls.Saturation = sliderSaturation.Value;
        //    colorCtrls.Contrast = sliderContrast.Value;
        //    // do the transformation
        //    using (var outputImage = colorCtrls.OutputImage)
        //    {
        //        var result = context.CreateCGImage(outputImage, outputImage.Extent);
        //        // display the result in the UIImageView
        //        imageView.Image = UIImage.FromImage(result);
        //    }
        //}


        public override void DidReceiveMemoryWarning()
        {
            base.DidReceiveMemoryWarning();
        }

        protected override void Dispose(bool disposing)
        {
            captureSession.Dispose();
            captureDeviceInput.Dispose();
            stillImageOutput.Dispose();
            base.Dispose(disposing);
        }

		
	}
}
