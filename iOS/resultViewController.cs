// This file has been autogenerated from a class added in the UI designer.

using System;
using CoreGraphics;
using CoreImage;
using Foundation;
using UIKit;
using System.CodeDom.Compiler;
using System.Drawing;
using System.Collections.Generic;
using OxyPlot;
using OxyPlot.Series;
using Xamarin.Forms;
using OxyPlot.Xamarin.iOS;

namespace OESApplication.iOS
{
	public partial class resultViewController : UIViewController
	{
        public string resultoutputtext;
        public NSData PixelArray;
        OESApplication.Binding.SpectraDetector _spectraDetector;
		public int x_crop_loc;
		public int y_crop_loc;
		public int widthOfCrossHair;
        public int HeightOfCrossHair;
		public int liveCameraHeight;
		public int liveCameraWidth;

		//UIImage srcImage;

		public resultViewController (IntPtr handle) : base (handle)
		{
            string filePath = NSBundle.MainBundle.PathForResource("cascade", "xml");
			Console.WriteLine(filePath);
		    _spectraDetector = new OESApplication.Binding.SpectraDetector(filePath);
		
		}

        public override void ViewDidLoad()
        {
            base.ViewDidLoad();
            DetectSpectraOpenCV();
        }


        private void DetectSpectraOpenCV(){
            
			UIImage srcImage = UIImage.LoadFromData(PixelArray);
			//UIImage srcImage = UIImage.FromBundle("lena1");
			//srcImage = MaxResizeImage(srcImage, 512, 512);
			Console.WriteLine("------");
			Console.WriteLine(srcImage.Size);
			int CorrectX = (int)((x_crop_loc * 1.0 / liveCameraWidth) * srcImage.Size.Width);
			int CorrectY = (int)((y_crop_loc * 1.0 / liveCameraHeight) * srcImage.Size.Height);

			var ratioX = (srcImage.Size.Width / liveCameraWidth);
			var ratioY = (srcImage.Size.Height / liveCameraHeight);
			Console.WriteLine("ratioX: " + ratioX);
			Console.WriteLine("ratioY: " + ratioY);

			srcImage = CropImage(srcImage, CorrectX, CorrectY, (int)(widthOfCrossHair * ratioX), (int)(HeightOfCrossHair * ratioY));
			Console.WriteLine("Width int: " + (int)(widthOfCrossHair * ratioX));
			Console.WriteLine("Width double: " + (widthOfCrossHair * ratioX));
			Console.WriteLine(srcImage.Size);
			Console.WriteLine("------");

            NSArray arrFaces = _spectraDetector.DetectSpectras(srcImage);

            //debug
            Console.WriteLine("faces count: {0}", arrFaces.Count);
			int minX = 1000;
			int minY = 1000;
			nuint desiredIndex = 0;
            for (nuint i = 0; i < arrFaces.Count; i++)
            {
                NSValue valRect = arrFaces.GetItem<NSValue>(i);
				if( valRect.CGRectValue.X <= (minX)){
					desiredIndex = i;
					minX = (int)valRect.CGRectValue.X;
					minY = (int)valRect.CGRectValue.Y;
				}
                Console.WriteLine("face: {0}" + i, valRect.CGRectValue);            
            }
			Console.WriteLine("desired index "+ desiredIndex);

			for (nuint i = 0; i < arrFaces.Count; i++)
			{
				NSValue valRect = arrFaces.GetItem<NSValue>(i);
				if ( (valRect.CGRectValue.Y <= (minY) && valRect.CGRectValue.Y>100)  && valRect.CGRectValue.X <= (minX+30))
				{
					desiredIndex = i;
                    minX = (int)valRect.CGRectValue.X;
                    minY = (int)valRect.CGRectValue.Y;
				}
				Console.WriteLine("face: {0}" + i, valRect.CGRectValue);
            }
            Console.WriteLine("desired index " + desiredIndex);
            
            //redraw image
			UIImage resultImage = this.DrawFaces(srcImage, arrFaces, desiredIndex);
            this.detectedSpectra.Image = resultImage;         

			resultImage.SaveToPhotosAlbum((image, error) => {
                var o = image as UIImage;
                Console.WriteLine("error:" + error);
            });


        }

		UIImage DrawFaces(UIImage srcImage, NSArray arrFaces, nuint desiredIndex)
        {
            UIGraphics.BeginImageContext(srcImage.Size);
            CGContext context = UIGraphics.GetCurrentContext();

            //draw src image
            srcImage.Draw(new CGRect(0, 0, srcImage.Size.Width, srcImage.Size.Height));
            
            //draw faces
            for (nuint i = 0; i < arrFaces.Count; i++)
            {
                NSValue valRect = arrFaces.GetItem<NSValue>(i);
                CGRect rect = valRect.CGRectValue;

                //draw
    //            context.SetStrokeColor(UIColor.Red.CGColor);
				//context.SetLineWidth(2);
                //context.StrokeRect(rect);
                
				if(i == desiredIndex){
					CGRect rectGreen = new CGRect(valRect.CGRectValue.X + 40, valRect.CGRectValue.Y + 10, valRect.CGRectValue.Width - 100, valRect.CGRectValue.Height - 10);
					Console.WriteLine("index " + i +" ", valRect.CGRectValue.Width-60);
					context.SetStrokeColor(UIColor.Green.CGColor);
					context.SetLineWidth(2);
					context.StrokeRect(rectGreen);

					CGRect rectGreen2 = new CGRect(valRect.CGRectValue.X + 220, valRect.CGRectValue.Y + 10, valRect.CGRectValue.Width - 100, valRect.CGRectValue.Height - 10);
					Console.WriteLine("index " + i + " ", valRect.CGRectValue.X + 150);
                    context.SetStrokeColor(UIColor.Green.CGColor);
                    context.SetLineWidth(2);
                    context.StrokeRect(rectGreen2);


					checkSpectraDifference(srcImage, valRect.CGRectValue.X + 20, valRect.CGRectValue.Y + 10, valRect.CGRectValue.Width - 60, valRect.CGRectValue.Height - 10);

				}
                
            }



            UIImage dstImage = UIGraphics.GetImageFromCurrentImageContext();

            UIGraphics.EndImageContext();
            return dstImage;
        }

		private void checkSpectraDifference(UIImage srcImage, nfloat x, nfloat y, nfloat width, nfloat height)
		{

			//this.detectedSpectra.Image.
			CGImage image = srcImage.CGImage.WithImageInRect(new CGRect(x, y, width, height));
			UIImage newImage = UIImage.FromImage(image);
			UIGraphics.BeginImageContext(newImage.Size);
			//CGContext context = UIGraphics.GetCurrentContext();

			CGColorSpace colorSpace = CGColorSpace.CreateDeviceRGB();


			var w = image.Width;
			var h = image.Height;

			Console.WriteLine("w and h: " + w + " " + h);
			Byte[] rawData = (new byte[(int)height * (int)width * 4]);
			int bytesPerPixel = 4;
			int bytesPerRow = bytesPerPixel * (int)width;
			int bitsPerComponent = 8;
			CGContext context = new CGBitmapContext(rawData, w, h, bitsPerComponent, bytesPerRow, colorSpace, CGBitmapFlags.ByteOrder32Big | CGBitmapFlags.PremultipliedLast);

			//CGContextDrawImage(context, new CGRect(0, 0, width, height), image);
			context.DrawImage(new CGRect(0, 0, width, height), image);
			UIGraphics.EndImageContext();

			//// Now your rawData contains the image data in the RGBA8888 pixel format.
			int count = (int)(w * h) * 4;
			Console.WriteLine("count " + count);
			//int byteIndex = (int)((bytesPerRow * y) + x * bytesPerPixel);
			int byteIndex = (int)((bytesPerRow) + bytesPerPixel);


			//var Points = new List<DataPoint> { };
			//var m = new PlotModel()
			//{
			//	PlotType = PlotType.XY
			//};

/*
 * For getting RGB Values
 * 
			//while((byteIndex) < (count-1)){
			for (int i = 0; i < count; i = i + 4)
			{
				//Console.WriteLine("byteIndex " + byteIndex + " i: "+i);
				var alpha = rawData[i + 3] / 255;
				var red = rawData[i] / alpha;
				var green = rawData[i + 1] / alpha;

				//Points.Add(new DataPoint(i, green));
			
				var blue = rawData[i + 2] / alpha;
				Console.WriteLine("byteIndex " + i + " red " + red + " green " + green + " blue" + blue + " alpha " + alpha);
				//byteIndex += bytesPerPixel;
			}
*/

			//var s = new LineSeries();
			//s.ItemsSource = Points;
			//m.Series.Add(s);
			//var opv = new OxyPlotView
			//{
			//	WidthRequest = 300,
			//	HeightRequest = 300,
			//	BackgroundColor = Color.Aqua
			//};
			//opv.Model = m;
            
			//var Content = new StackLayout
   //         {
   //             Children = {
   //                     new Label {
   //                     Text = "Hello, Oxyplot!",
   //                     VerticalOptions = LayoutOptions.CenterAndExpand,
   //                     HorizontalOptions = LayoutOptions.CenterAndExpand,
   //                     },
   //                 opv,
   //                 new Label {
   //                     Text = "http://oxyplot.org/doc/HelloWpfXaml.html",
   //                     Font = Font.SystemFontOfSize(NamedSize.Small),
   //                     VerticalOptions = LayoutOptions.CenterAndExpand,
   //                     HorizontalOptions = LayoutOptions.CenterAndExpand,
   //                 },
   //             }
   //         };
			//this.StackView = (UIKit.UIStackView)Content.BindingContext;
					   



			//this.detectedSpectra.Add((UIKit.UIView)Content);
            
			//this.detectedSpectra.Image = newImage;
		}



		// resize the image to be contained within a maximum width and height, keeping aspect ratio
		public UIImage MaxResizeImage(UIImage sourceImage, float maxWidth, float maxHeight)
        {
            var sourceSize = sourceImage.Size;
			var maxResizeFactor = Math.Min(maxWidth / sourceSize.Width, maxHeight / sourceSize.Height);
            if (maxResizeFactor > 1) return sourceImage;
            var width = maxResizeFactor * sourceSize.Width;
            var height = maxResizeFactor * sourceSize.Height;
            UIGraphics.BeginImageContext(new SizeF((float)width, (float)height));
			sourceImage.Draw(new RectangleF(0, 0, (float)width, (float)height));
            var resultImage = UIGraphics.GetImageFromCurrentImageContext();
            UIGraphics.EndImageContext();
            return resultImage;
        }

        // resize the image (without trying to maintain aspect ratio)
        public UIImage ResizeImage(UIImage sourceImage, float width, float height)
        {
			UIGraphics.BeginImageContext(new SizeF(width, height));
			sourceImage.Draw(new RectangleF(0, 0, width, height));
            var resultImage = UIGraphics.GetImageFromCurrentImageContext();
            UIGraphics.EndImageContext();
            return resultImage;
        }

        // crop the image, without resizing
        private UIImage CropImage(UIImage sourceImage, int crop_x, int crop_y, int width, int height)
        {
            var imgSize = sourceImage.Size;
            UIGraphics.BeginImageContext(new SizeF(width, height));
            var context = UIGraphics.GetCurrentContext();
            var clippedRect = new RectangleF(0, 0, width, height);
            context.ClipToRect(clippedRect);
			var drawRect = new RectangleF(-crop_x, -crop_y, (float)imgSize.Width, (float)imgSize.Height);
            sourceImage.Draw(drawRect);
            var modifiedImage = UIGraphics.GetImageFromCurrentImageContext();
            UIGraphics.EndImageContext();
            return modifiedImage;
        }

        //private void getPixelArray(byte[] jpegAsByteArray){
        //    try
        //    {
        //        for (int i = 0; i < jpegAsByteArray.Length-4; i += 4)
        //        {
        //            var r = jpegAsByteArray.GetValue(i);
        //            var g = jpegAsByteArray.GetValue(i + 1);
        //            var b = jpegAsByteArray.GetValue(i + 2);
        //            var a = jpegAsByteArray.GetValue(i + 3);
        //            //Console.WriteLine(r + " " + b + " " + g + " " + a);
        //        }
        //    }
        //    catch (Exception ex)
        //    {
        //        Console.WriteLine(ex.Message);
        //    }

        //}
	
    
    
    
    }
}
